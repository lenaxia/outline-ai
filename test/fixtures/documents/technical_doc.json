{
  "id": "doc-tech-api-design-001",
  "collectionId": "col-engineering-001",
  "title": "API Authentication & Rate Limiting",
  "text": "# API Authentication & Rate Limiting\n\n## Overview\n\nThis document outlines our REST API authentication mechanism and rate limiting strategy for external integrations.\n\n## Authentication\n\n### Bearer Token Authentication\n\nAll API requests must include a Bearer token in the Authorization header:\n\n```bash\ncurl -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  https://api.example.com/v1/users\n```\n\n### Token Generation\n\nAPI tokens are generated through the admin dashboard:\n\n1. Navigate to Settings > API Keys\n2. Click \"Generate New Key\"\n3. Set expiration (30/90/365 days or never)\n4. Copy the key immediately (shown only once)\n\n### Token Scopes\n\nTokens can be scoped to specific permissions:\n\n- `read:users` - Read user data\n- `write:users` - Create/update users\n- `read:documents` - Access documents\n- `write:documents` - Modify documents\n- `admin:*` - Full administrative access\n\n## Rate Limiting\n\n### Tiered Limits\n\nWe implement tiered rate limiting based on subscription level:\n\n| Tier | Requests/Hour | Requests/Day | Burst Limit |\n|------|--------------|--------------|-------------|\n| Free | 100 | 1,000 | 10/min |\n| Pro | 1,000 | 50,000 | 100/min |\n| Enterprise | 10,000 | 500,000 | 1000/min |\n\n### Rate Limit Headers\n\nAll API responses include rate limit information:\n\n```http\nX-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 987\nX-RateLimit-Reset: 1642521600\n```\n\n### Handling 429 Responses\n\nWhen rate limited, the API returns HTTP 429:\n\n```json\n{\n  \"error\": \"rate_limit_exceeded\",\n  \"message\": \"Too many requests\",\n  \"retry_after\": 60\n}\n```\n\nImplement exponential backoff:\n\n```python\nimport time\nimport requests\n\ndef api_request_with_retry(url, headers, max_retries=3):\n    for attempt in range(max_retries):\n        response = requests.get(url, headers=headers)\n\n        if response.status_code == 429:\n            retry_after = int(response.headers.get('Retry-After', 60))\n            time.sleep(retry_after * (2 ** attempt))\n            continue\n\n        return response\n\n    raise Exception('Max retries exceeded')\n```\n\n## Implementation Details\n\n### Token Bucket Algorithm\n\nWe use a token bucket algorithm for rate limiting:\n\n1. Each user has a bucket with N tokens\n2. Each request consumes 1 token\n3. Tokens refill at rate R per second\n4. Burst capacity allows temporary spikes\n\n### Redis-Based Tracking\n\nRate limit state stored in Redis:\n\n```redis\nKEY: ratelimit:{user_id}\nVALUE: {tokens_remaining}\nTTL: {window_duration}\n```\n\n### Whitelisting\n\nCritical integrations can be whitelisted:\n- Health monitoring services\n- Payment processors\n- Emergency response systems\n\n## Best Practices\n\n### For API Consumers\n\n1. **Cache responses** when possible\n2. **Use webhooks** instead of polling\n3. **Implement backoff** for 429 responses\n4. **Monitor rate limit headers** proactively\n5. **Batch requests** where supported\n\n### For API Developers\n\n1. **Document limits** clearly\n2. **Provide informative errors** with retry guidance\n3. **Log rate limit events** for monitoring\n4. **Consider graduated limits** for burst traffic\n5. **Whitelist** known-good actors\n\n## Monitoring\n\n### Metrics to Track\n\n- Rate limit hits per user\n- 429 response rates\n- Token consumption patterns\n- Burst usage frequency\n\n### Alerts\n\nSet up alerts for:\n- Sustained 429 responses (> 5% of requests)\n- Individual users hitting limits repeatedly\n- Unusual traffic patterns\n\n## References\n\n- [RFC 6750: Bearer Token Usage](https://tools.ietf.org/html/rfc6750)\n- [Token Bucket Algorithm](https://en.wikipedia.org/wiki/Token_bucket)\n- [API Design Guidelines](/docs/api-design-guidelines)\n\n## Changelog\n\n- 2024-01-15: Initial documentation\n- 2024-01-20: Added Python code example\n- 2024-02-01: Updated rate limit tiers",
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-02-01T14:22:00Z",
  "publishedAt": "2024-01-15T11:00:00Z"
}
